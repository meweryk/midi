<!DOCTYPE html>
<html lang="ru">
<head>
    <!--
  Copyright 2024 meweryk

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

    Лицензировано под Apache License, Version 2.0 (далее "Лицензия");
  вы не можете использовать этот файл кроме как в соответствии с Лицензией.
  Вы можете получить копию Лицензии по адресу:

      http://www.apache.org/licenses/LICENSE-2.0

  Если это не требуется по применимому законодательству или не согласовано в письменной форме,
  программное обеспечение, распространяемое по Лицензии, распространяется на условиях "КАК ЕСТЬ",
  БЕЗ каких-либо гарантий или условий явных или подразумеваемых.
-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="manifest" href="./manifest.json">
    <link rel="icon" href="./icon-192.png">
    <meta name="theme-color" content="#3a4a58">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <title>Генератор частот с FM модуляцией</title>
    <style>
        :root {
            --primary-color: #3a4a58;
            --secondary-color: #5d7b94;
            --accent-color: #6bb9f0;
            --background-color: #a6c2ec;
            --control-bg: #e8ecef;
            --border-color: #d1d9e0;
            --text-color: #333;
            --success-color: #7bc67e;
            --danger-color: #f28b82;
            --info-color: #8ab4f8;
        }
        
        body {
            font-family: 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            /* Уменьшаем отступы, чтобы соответствовать более короткой шапке/подвалу */
            padding-top: 45px; /* Новый отступ для короткой шапки */
            padding-bottom: 45px; /* Новый отступ для подвала */
            margin-left: auto; /* Центрирование содержимого */
            margin-right: auto; /* Центрирование содержимого */
            min-height: 100vh; 
            display: flex;
            flex-direction: column;
            /*margin: 10px;*/
            max-width: 800px;
            font-size: 0.9em;
            background-color: var(--background-color);
            color: var(--text-color);
        }
        li {
            font-size: 0.8em;
        }
        .control {
            margin: 8px 0;
            padding: 10px;
            border: 1px solid var(--border-color);
            background: var(--control-bg);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .control-block {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid var(--border-color);
            background: var(--control-bg);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        } 
        .frequency-item {
            margin: 6px 0;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            position: relative;
        }
        .divider {
            height: 2px;
            background: #999;
            margin: 10px 0;
            width: 100%;
        }
        .color-box {
            width: 25px;
            height: 25px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        th, td {
            padding: 8px;
            border: 1px solid var(--border-color);
            text-align: center;
        }
        th {
            background-color: var(--secondary-color);
            color: white;
        }
        input[type="range"] {
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: var(--border-color);
            appearance: none;
            -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--secondary-color);
            cursor: pointer;
        }
        input[type="range"].phase-shift {
            width: 160px;
        }
        input[type="range"].phase-shift::-webkit-slider-thumb {
            background: var(--accent-color);
        }
        button {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.9em;
            border: none;
            transition: all 0.2s ease;
        }
        .main-btn {
            background: var(--secondary-color);
            color: white;
        }
        button.main-btn.active {
            background-color: var(--success-color);
        }
        .remove-btn {
            background: var(--danger-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: auto;
            font-weight: bold;
        }
        .pan-selector {
            margin: 0 5px;
            padding: 5px;
            width: 60px;
            font-size: 0.9em;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: white;
        }
        .phase-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        input[type="number"] {
            font-size: 0.9em;
            padding: 5px;
            width: 80px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: white;
        }
        .wave-controls {
            margin-top: 8px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .wave-btn {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.9em;
            background: var(--secondary-color);
            color: white;
        }
        .wave-btn.active {
            background-color: var(--success-color);
        }
        .fm-controls {
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            padding: 10px;
            background: rgba(107, 185, 240, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(107, 185, 240, 0.3);
        }
        .fm-label {
            font-weight: 600;
            color: var(--text-color);
        }
        .info-button {
            font-size: 18px;
            background-color: var(--accent-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            text-align: center;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal {
            display: none; 
            position: fixed;
            z-index: 1;
            left: 0; top: 0;
            width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: var(--background-color);
            margin: 15% auto;
            padding: 25px;
            border-radius: 12px;
            width: 320px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            position: relative;
            max-height: 80vh;
            overflow-y: auto;
        }

        .close {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 20px;
            font-weight: bold;
            color: var(--secondary-color);
            cursor: pointer;
        }

        .close:hover {
            color: var(--primary-color);
        }
        
        .name-prompt-modal {
        	display: none;
        	position: fixed;
        	z-index: 2;
        	left: 0;
        	top: 0;
        	width: 100%;
        	height: 100%;
        	background-color: rgba(0,0,0,0.5);
        }
        
        .name-prompt-content {
        	background-color: var(--background-color);
        	margin: 20% auto;
        	padding: 20px;
        	border-radius: 8px;
        	width: 320px;
        	box-shadow: 0 4px 20px rgba(0,0,0,0.15);
        }
        
        .save-list-container {
            margin: 10px 0;
        }
        
        .saved-lists-header {
            cursor: pointer;
            padding: 10px;
            background: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
        }
        
        .saved-lists-header::after {
            content: "▼";
            font-size: 0.8em;
        }
        
        .saved-lists-content {
            display: none;
            margin-top: 8px;
            border: 1px solid var(--border-color);
            padding: 10px;
            border-radius: 6px;
            background: white;
        }
        
        .saved-list-btn {
            display: block;
            width: 100%;
            margin: 3px 0;
            padding: 7px;
            text-align: left;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .saved-list-btn:hover {
            background: #f0f4f8;
            border-color: var(--accent-color);
        }
        
        .delete-preset-btn {
        	background: var(--danger-color);
        	color: white;
        	border: none;
        	border-radius: 50%;
        	width: 28px;
        	height: 28px;
        	display: flex;
        	align-items: center;
        	justify-content: center;
        	cursor: pointer;
        	margin-left: 10px;
        	font-weight: bold;
        	transition: all 0.2s ease;
        }
        
        .delete-preset-btn:hover {
        	transform: scale(1.1);
        }
        
        #saveListBtn, #exportBtn, #importBtn {
            margin-top: 20px;
            padding: 10px 16px;
            background: var(--success-color);
            color: white;
            border: none;
            margin-right: 8px;
            font-weight: 500;
        }
        
        #exportBtn {
            background: var(--accent-color);
        }
        
        #importBtn {
            background: #FF9800;
        }
        
        .info-container {
            margin: 10px 0;
        }
        
        .info-header {
            cursor: pointer;
            padding: 10px;
            background: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
        }
        
        .info-header::after {
            content: "▼";
            font-size: 0.8em;
        }
        
        .info-content {
            display: none;
            margin-top: 10px;
            border: 1px solid var(--border-color);
            padding: 15px;
            border-radius: 6px;
            background: white;
        }
        
        .quick-preset-container {
            margin: 10px 0;
            display: flex;
            gap: 8px;
        }
        #quickPresetInput {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: white;
        }
        #quickSaveBtn {
            padding: 10px 16px;
            background: var(--success-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        
        #quickSaveBtn:hover {
            background: #6bb06e;
        }
        
        .saved-item-container {
        	display: flex;
        	align-items: center;
        	margin-bottom: 8px;
        }
        
        .saved-item-name {
        	flex-grow: 1;
        	text-align: left;
        }
        
        #scrollToTopBtn {
            position: fixed;
            bottom: 25px;
            right: 25px;
            display: none;
            z-index: 99;
            padding: 12px 16px;
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            transition: all 0.2s ease;
        }
        #scrollToTopBtn:hover {
            background-color: var(--accent-color);
            transform: translateY(-2px);
        }
        
        .accordion-container {
            width: 100%;
            margin: 12px 0;
        }
        .accordion-btn {
            width: 100%;
            padding: 12px 15px;
            text-align: left;
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        .accordion-btn:hover {
            background-color: #4c5e6f;
        }
        .accordion-btn::after {
            content: "▼";
            font-size: 0.8em;
        }
        .accordion-btn.expanded::after {
            content: "▲";
        }
        .accordion-content {
            display: none;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-top: none;
            border-radius: 0 0 6px 6px;
            background: white;
        }
        @media (max-width: 600px) {
            .accordion-btn {
                font-size: 0.9em;
                padding: 10px 12px;
            }
             /* Уменьшение отступа main-content на мобильных экранах для лучшего использования пространства */
            .main-content {
                padding: 10px; 
            }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .control, .accordion-content {
            animation: fadeIn 0.3s ease-out;
        }
        
        /* Новые стили для WAV генерации */
        .wav-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }
        
        .wav-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .wav-param {
            flex: 1;
            min-width: 150px;
        }
        
        .wav-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
        }
        
        .wav-modal-content {
            background-color: var(--background-color);
            margin: 10% auto;
            padding: 20px;
            border-radius: 10px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }
        
        .progress-container {
            margin: 15px 0;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
        }
        
        .progress-bar {
            height: 100%;
            background-color: var(--accent-color);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .wav-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
        }
        
        .wav-option {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        /* Стили для визуализации */
        .visualizer-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 10px 0;
        }
        
        .visualizer-canvas {
            width: 100%;
            height: 200px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background-color: #000;
        }
        
        /* Стили для поля громкости */
        .volume-control {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .volume-input {
            width: 60px !important;
            text-align: center;
        }
        
        .volume-icon {
            font-size: 16px;
            color: var(--secondary-color);
        }
        /* Пользовательские стили для шапки (Navbar) */
        .navbar-custom {
            background-color: var(--primary-color) !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding-top: 5px !important; 
            padding-bottom: 5px !important; 
            min-height: 45px; /* Минимальная высота для короткой шапки */
        }
        /*Уменьшение размера иконки меню */
        .navbar-toggler-icon {
            width: 1.2em;
            height: 1.2em;
        }
        /* Стиль для заголовка в шапке */
        .navbar-brand-custom {
            color: var(--accent-color) !important;
            font-weight: 600;
        }
        /* Стиль для всплывающего меню (Offcanvas) */
        .offcanvas-custom {
            background-color: var(--primary-color);
        }
        .offcanvas-header {
            border-bottom: 1px solid var(--secondary-color);
        }

        /* Отступ для основного контента */
        .main-content {
            padding: 20px 10px 10px 10px;
            flex-grow: 1; 
        }
        /* Стиль для подвала (Footer) */
        .footer-custom {
            background-color: var(--primary-color);
            box-shadow: 0 -2px 4px rgba(0, 0, 0, 0.1);
            /* Убрано width: 100%; т.к. fixed-bottom обеспечивает полную ширину viewport */
            padding-top: 5px !important;
            padding-bottom: 5px !important;
            min-height: 40px; /* Минимальная высота для короткого подвала */
        }
        .footer-custom p {
            color: var(--accent-color) !important;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <!-- Шапка (Header/Navbar) с кнопкой всплывающего меню -->
    <nav class="navbar navbar-dark navbar-custom fixed-top">
        <div class="container-fluid">
            <!-- Заголовок приложения -->
            <span class="navbar-brand navbar-brand-custom me-auto ms-3 h1">Генератор частот</span>
            
            <!-- Кнопка всплывающего меню (Offcanvas Trigger) справа -->
            <button class="navbar-toggler" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasNavbar" aria-controls="offcanvasNavbar" aria-label="Открыть меню">
                <span class="navbar-toggler-icon"></span>
            </button>
            
            <!-- Всплывающее меню (Offcanvas) -->
            <div class="offcanvas offcanvas-end offcanvas-custom" tabindex="-1" id="offcanvasNavbar" aria-labelledby="offcanvasNavbarLabel">
                <div class="offcanvas-header">
                    <h5 class="offcanvas-title navbar-brand-custom" id="offcanvasNavbarLabel">Навигация</h5>
                    <!-- Кнопка закрытия для темного фона -->
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="offcanvas" aria-label="Закрыть"></button>
                </div>
                <div class="offcanvas-body">
                    <!-- Ссылки пользователя в виде кнопок для удобства -->
                    <div class="d-grid gap-2">
                        <a href="./kolokol0018.html" class="btn btn-outline-light">Генератор колокольного звона</a>
                        <a href="./calc_music.html" class="btn btn-outline-light">Анализ музыкального строя с оптимизацией</a>
                        <a href="./processorG.html" class="btn btn-outline-light">Аудиоплеер фазовращатель</a>
                        <a href="./Raman-ir-uv.html" class="btn btn-outline-light">Конвертер спектров в звук</a>
                        <hr class="text-white-50">
                        <a href="./LICENSE" class="btn btn-outline-light">Лицензионное соглашение</a>
                        <a href="./README.md" class="btn btn-outline-light">О программе</a>
                        <a href="https://meweryk.github.io/Wave-of-land/index.html" class="btn btn-outline-light">Ещё проекты</a>
                    </div>
                </div>
            </div>
        </div>
    </nav>


    <div class="main-content">
    
    <div class="control">
        <div style="display: flex; gap: 8px; margin-bottom: 10px;">
            <button id="toggleBtn" class="main-btn">Старт</button>
            <button id="addFrequency" class="main-btn">+ Добавить частоту</button>
            <button class="main-btn info-button" onclick="openModal()">i</button>
        </div>
        
        <div class="wave-controls">
            <button id="sineBtn" class="wave-btn active">Синус</button>
            <button id="squareBtn" class="wave-btn">Меандр</button>
            <button id="cycleFrequencies" class="wave-btn">перебор частот</button>
        </div>
        
        <div class="fm-controls">
            <input type="checkbox" id="fmEnabled">
            <span class="fm-label">FM модуляция:</span>
            
            <span class="fm-label">Частота (Гц):</span>
            <input type="number" id="fmFreq" min="0" max="100" value="0" step="0.001" style="width: 80px;">
            
            <span class="fm-label">Девиация (%):</span>
            <input type="number" id="fmDepth" min="0" max="5" value="0" step="0.01" style="width: 70px;">
        </div>
    </div>
    
    <!-- Контейнер для визуализации -->
    <div class="control">
        <h6 style="text-align: center;">Визуализация выходного сигнала</h3>
        <div class="visualizer-container">
            <canvas id="oscilloscopeCanvas" class="visualizer-canvas"></canvas>
            <canvas id="lissajousCanvas" class="visualizer-canvas"></canvas>
        </div>
    </div>
    
    <div class="accordion-container">
        <button class="accordion-btn" onclick="toggleAccordion('freqAccordion')">Настройка частот</button>
        <div class="accordion-content" id="freqAccordion">
            <div id="frequencyControls" class="control"></div>
        </div>
    </div>
    
    <div class="accordion-container">
        <button class="accordion-btn" onclick="toggleAccordion('colorAccordion')">Таблица цветов</button>
        <div class="accordion-content" id="colorAccordion">
            <table>
                <thead>
                    <tr>
                        <th>Звук (Гц)</th>
                        <th>Свет (ТГц)</th>
                        <th>Длина волны</th>
                        <th>Цвет</th>
                    </tr>
                </thead>
                <tbody id="results"></tbody>
            </table>
        </div>
    </div>
    
    <div class="control-block">
        <button id="saveListBtn" title="Сохранить список">💾 настройки</button>
        <button id="exportBtn">Экспорт</button>
        <button id="importBtn">Импорт</button>
        <input type="file" id="csvFileInput" accept=".csv" style="display: none;">
    </div>
    
    <button id="saveToWavBtn" class="main-btn" style="width: calc(100% - 20px); margin: 0 10px; display: none;">
    	Сохранить в WAV файл
    </button>
    
    <div class="control-block">
        <div class="quick-preset-container">
            <input type="text" id="quickPresetInput" placeholder="Введите частоты в формате: частота,громкость; частота,громкость; ...">
            <button id="quickSaveBtn" title="Сохранить пресет">💾</button>
        </div>
    </div>
    
    <div class="save-list-container control">
        <div class="saved-lists-header" onclick="toggleSavedLists()">
            Список сохранённых частот
        </div>
        <div class="saved-lists-content" id="savedListsContent"></div>
    </div>
    
    <div class="info-container control">
        <div class="info-header" onclick="toggleInfo()">
            Информация о частотах планет и ДНК
        </div>
        <div class="info-content mb-2" id="infoContent">
            <ul>
                <li>Идеальный 5-й ключ ДНК: гармонизированный с
                    частотами D 288 Гц и А 432 Гц, он является краеугольным камнем коллекции.</li>
                <li>Идеальная 5-я клавиша F/C: настроена на частоту F 324 Гц и С 512 Гц, предлагая новое измерение исследования гармоник.</li>
                <li>Дельта-клавиша: уникально настроена на ноту D на обоих концах со смещением на 3 Гц, создавая дельта-бинауральную частоту, способствующую глубокой медитации и регенерации.</li>
                <li>Тета-ключ: настроен на ноту А на обоих концах и смещен на 6 Гц, он создает тета-бинауральную частоту, способствующую состоянию расслабленного осознания и открывая доступ к подсознанию.</li>
            </ul>
            <h3>Тона планет</h3>
            <ul>
                <li>
                    <b>Тон Меркурия.</b><br>  			
                    141.27 Hz<br>    			
                    Цвет: сине-зеленый<br>   			
                    Чакра: Вишудха горловая чакра<br>    			
                    Эффект: поддерживает центр речи, коммуникацию и интеллектуальную деятельность.
                </li>
                <li>
                    <b>Тон Венеры.</b><br>  			
                    221.23 Hz<br>    			
                    Цвет: желто-оранжевый<br>    			
                    Чакra: Аджна надбровная чакра, третий глаз<br>    			
                    Эффект: поддерживает высшую любовную энергию и стремление к гармонии.
                </li>
                <li>
                    <b>Тон Марса.</b><br>    			
                    144.72 Hz<br>    			
                    Цвет: синий<br>    			
                    Эффект: поддерживает силу воли и сфокусированную энергию
                </li>
                <li>			
                    <b>Тон Юпитера.</b><br>    			
                    183.58 Hz<br>    			
                    Цвет: красный<br>    			
                    Эффект: поддерживает творческую силу.
                </li>
                <li>    			
                    <b>Тон Сатурн.</b><br>   			
                    147.85 Hz<br>   			
                    Цвет: синий<br>  			
                    Эффект: усиливает концентрацию и осознанность.
                </li>
                <li>
                    <b>Тон Урана.</b><br>    			
                    207.36 Hz<br>    			
                    Цвет: оранжевый<br>    			
                    Эффект: поддерживает силу удивления и обновления, обладает первобытной и эротической силой.    			
                </li>
                <li>
                    <b>Тон Нептуна.</b><br>    			
                    211.44 Hz<br>    			
                    Цвет: оранжевый<br>    			
                    Эффект: поддерживает интуицию, подсознание и усиливает переживания во сне.    			
                </li>
                <li>
                    <b>Тон Плутона.</b><br>   			
                    140.64 Hz<br>			
                    Цвет: сине-зеленый<br>   			
                    Эффект: поддерживает магическую групповую динамику и отвечает за интеграцию в определенные структуры общества.
                </li>
                <li>
                    <b>Тон Солнца.</b><br>   			
                    126.22 Hz<br>    			
                    Цвет: желто-зеленый<br>   			
                    Чакra: Манипуura солнечное сплетение	(Xapa)<br>    			
                    Эффект: усиливает ощущение концентрации на магическом и трансцендентном.<br>   			
                    Солнце это энергетический центр нашей солнечной системы. Оно является центром притяжения, вокруг которого вращаются Земля и другие планеты. Поэтому частота солнца связана с психическим центром. В Дзене эта точка называется Хара. Тон солнца это граница между Инь и Ян, между этой и другой стороной. Он поднимается из высшего измерения и, лишенной рационального наблюдения, символизирует нечто магическое и трансцендентное. 			
                    Солнечный тон следует использовать после работы с другими тонами и в первую очередь для продвинутых практиков.
                </li>
            </ul>   
            <p>Основано на источнике <a href="https://www.planetware.de/octave/">Planetware</a>, где можно скачать эти тона.
           </p>
        </div>        
    </div>
    
    <button id="scrollToTopBtn" title="Наверх">↑</button>

    <div id="infoModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeModal()">&times;</span>
            <h3>Информация о синтезаторе</h3>
            <p>Это простой синтезатор для генерации частот и тестирования родинского бублика.</p>
            
            <ul>
            <li>Добавление осцилляторов</li>
            <li>Определение для каждого осциллятора канала: правого (R), левого (L) или вывода на два сразу (С)</li>
            <li>Установка сдвига фазы (до 180°) между осцилляторами</li>
            <li>Расчёт длины волны в видимом диапазоне при октавном увеличении частоты звука</li>
            <li>Цветовая шкала длины волны</li>
            <li>Настройка громкости каждого осциллятора в % от максимальной громкости</li>
            </ul>
            <h3>Особенности:</h3>
            <ul>
            <li>Возможность изменения частоты в настоящее время</li>
            <li><strong>Важно:</strong> изменение выводов на соединениях — только через остановку и повторный запуск</li>
            <li>Переход фазы корректно отрабатывает только после остановки и нового старта</li>
            <li>Добавлена нормализация амплитуды для предотвращения клиппинга</li>
            <li>Реализован компрессор для мягкого ограничения сигнала</li>
            <li>Перебор частот: проигрывает по 2 частоты с введённого пресета, каждую пару частот по 3 минуты, после чего воспроизведение останавливается</li>
            <li>Громкость осцилляторов: если поле громкости заполнено - используется указанное значение, иначе рассчитывается автоматически</li>
            <li>Формат быстрого сохранения: "частота,громкость; частота,громкость; ..."</li>
            </ul>
            <h3>FM модуляция в генераторе</h3>
            <p>Реализована точная частотная модуляция (FM) по формуле:</p>
            <p><strong>f(t) = f₀ + Δf × sin(2πfₘt)</strong></p>
            <p>где:</p>
            <ul>
                <li><strong>f(t)</strong> - мгновенная частота</li>
                <li><strong>f₀</strong> - основная частота осциллятора</li>
                <li><strong>Δf</strong> - девиация частоты (Δf = f₀ × depth / 100)</li>
                <li><strong>fₘ</strong> - частота модуляции</li>
            </ul>
            
            <h4>Параметры:</h4>
            <ul>
                <li><strong>Включение:</strong> флажок активирует/деактивирует FM модуляцию</li>
                <li><strong>Частота модуляции:</strong> 0-100 Гц (шаг 0.001 Гц)</li>
                <li><strong>Девиация:</strong> 0-5% от основной частоты (шаг 0.01%)</li>
            </ul>
            
            <p>FM модуляция применяется ко всем активным осцилляторам одновременно.</p>
            <p>Проект синтезатора разрабатывается для генерации частот и исследования катушки <strong>РодоФон</strong>, сделанной по принципу <strong>Марко Родина</strong>.</p>
        </div>
    </div>
    
    <div id="namePromptModal" class="name-prompt-modal">
        <div class="name-prompt-content">
            <h3>Сохранение списка</h3>
            <p>Введите название для вашего списка частот:</p>
            <input type="text" id="listNameInput" style="width: 100%; padding: 8px; margin: 10px 0; box-sizing: border-box;">
            <div style="display: flex; justify-content: space-between;">
                <button onclick="document.getElementById('namePromptModal').style.display = 'none'">Отмена</button>
                <button onclick="confirmSaveList()" style="background: #4CAF50; color: white;">Сохранить</button>
            </div>
        </div>
    </div>
    
    <!-- Модальное окно для сохранения WAV -->
    <div id="wavModal" class="wav-modal">
        <div class="wav-modal-content">
            <h3 id="wavModalTitle">Сохранить пресет в WAV файл</h3>
            
            <div class="wav-options">
                <div class="wav-option">
                    <input type="checkbox" id="wavFmEnabled" checked>
                    <label for="wavFmEnabled">FM модуляция</label>
                </div>
                
                <div class="wav-option">
                    <input type="checkbox" id="wavStereo" checked>
                    <label for="wavStereo">Стерео</label>
                </div>
                
                <div class="wav-option">
                    <input type="checkbox" id="wavCompress" checked>
                    <label for="wavCompress">Компрессия</label>
                </div>
            </div>
            
            <div class="wav-controls">
                <div class="wav-row">
                    <div class="wav-param">
                        <label for="wavDuration">Длительность (сек):</label>
                        <input type="number" id="wavDuration" min="1" max="600" value="180" style="width: 100%;">
                    </div>
                    
                    <div class="wav-param">
                        <label for="wavSampleRate">Частота дискр.:</label>
                        <select id="wavSampleRate" style="width: 100%;">                          
                            <option value="48000" selected>48 kHz</option>
                            <option value="24000">24 kHz</option>
                        </select>
                    </div>
                </div>
                
                <div class="wav-row">
                    <div class="wav-param">
                        <label for="wavBitDepth">Битовая глубина:</label>
                        <select id="wavBitDepth" style="width: 100%;">
                            <option value="16">16 бит</option>
                            <option value="24">24 бита</option>
                            <option value="32">32 бита</option>
                        </select>
                    </div>
                    
                    <div class="wav-param">
                        <label for="wavVolume">Громкость (%):</label>
                        <input type="range" id="wavVolume" min="0" max="100" value="100" style="width: 100%;">
                    </div>
                </div>
            </div>
            
            <div class="progress-container">
                <div id="wavProgress" class="progress-bar"></div>
            </div>
            <p id="wavStatus">Готов к генерации...</p>
            
            <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                <button onclick="document.getElementById('wavModal').style.display = 'none'">Отмена</button>
                <button onclick="startWavGeneration()" style="background: #4CAF50; color: white;">Генерировать</button>
            </div>
        </div>
    </div>
    </div>

    <!-- Подвал (Footer) - Теперь с fixed-bottom для полной ширины -->
    <footer class="footer-custom py-2 text-center fixed-bottom">
        <p class="m-0 small">Автор</p>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  
    <script>
        let audioContext;
        let isPlaying = false;
        const channels = new Map();
        let currentWaveType = 'sine';
        let masterGain;
        let fmOscillator;
        let fmEnabled = false;
        let fmFreq = 0;
        let fmDepth = 0;
        let currentPresetName = null;
        let wavWorker;
        
        let isFrequencyCycling = false;
        let cycleInterval;
        let countdownInterval;
        let currentPairIndex = 0;
        let currentPairOscillators = [];
        let totalCycleTime = 0;
        let remainingTime = 0;
        let frequencyPairs = [];
        
        const frequencyListsStorageKey = 'savedFrequencyLists';
        
        // Переменные для визуализации
        let oscilloscopeCanvas, lissajousCanvas;
        let oscilloscopeCtx, lissajousCtx;
        let leftAnalyser, rightAnalyser;
        let visualizerAnimationId;
        
        // Конфигурация визуализации
        const visualizerConfig = {
            visibleSamples: 1024,
            amplitudeScale: 0.8,
            lineWidth: 2,
            leftChannelColor: '#00ff00',
            rightChannelColor: '#ff0000'
        };
        
        function getSavedFrequencyLists() {
            const saved = localStorage.getItem(frequencyListsStorageKey);
            return saved ? JSON.parse(saved) : {};
        }
        
        function saveFrequencyLists(lists) {
            localStorage.setItem(frequencyListsStorageKey, JSON.stringify(lists));
        }
        
        function showNamePrompt() {
            document.getElementById('namePromptModal').style.display = 'block';
            document.getElementById('listNameInput').value = '';
            document.getElementById('listNameInput').focus();
        }
        
        function confirmSaveList() {
            const listName = document.getElementById('listNameInput').value.trim();
            if (!listName) {
                alert('Пожалуйста, введите название списка');
                return;
            }
            
            saveCurrentList(listName);
            document.getElementById('namePromptModal').style.display = 'none';
        }
        
        function saveCurrentList(listName) {
            const frequencyItems = document.querySelectorAll('.frequency-item');
            const frequencies = [];
            
            frequencyItems.forEach(item => {
                const id = item.dataset.id;
                const freq = parseFloat(item.querySelector('.freq-range').value);
                const phaseShift = parseFloat(item.querySelector('.phase-shift').value);
                const pan = parseFloat(item.querySelector('.pan-selector').value);
                const volume = item.querySelector('.volume-input').value.trim();
                
                frequencies.push({
                    freq: parseFloat(freq.toFixed(6)),
                    phaseShift: parseFloat(phaseShift.toFixed(3)),
                    pan: parseFloat(pan.toFixed(3)),
                    volume: volume ? parseFloat(volume) : null
                });
            });
            
            const fmParams = {
                enabled: document.getElementById('fmEnabled').checked,
                freq: parseFloat(parseFloat(document.getElementById('fmFreq').value || 0).toFixed(6)),
                depth: parseFloat(parseFloat(document.getElementById('fmDepth').value || 0).toFixed(3))
            };
            
            const listData = {
                frequencies,
                fm: fmParams
            };
            
            const savedLists = getSavedFrequencyLists();
            savedLists[listName] = listData;
            saveFrequencyLists(savedLists);
            
            renderSavedLists();
            
            currentPresetName = listName;
            document.getElementById('saveToWavBtn').style.display = 'block';
            
            alert(`Список "${listName}" успешно сохранен!`);
        }
        
        function renderSavedLists() {
            const savedLists = getSavedFrequencyLists();
            const container = document.getElementById('savedListsContent');
            container.innerHTML = '';
            
            if (Object.keys(savedLists).length === 0) {
                container.innerHTML = '<p>Нет сохранённых списков</p>';
                return;
            }
            
            const sortedNames = Object.keys(savedLists).sort();
            
            sortedNames.forEach(name => {
                const containerDiv = document.createElement('div');
                containerDiv.className = 'saved-item-container';
                
                const btn = document.createElement('button');
                btn.className = 'saved-list-btn saved-item-name';
                btn.textContent = name;
                btn.onclick = () => applyFrequencyList(name, savedLists[name]);
                
                const deleteBtn = document.createElement('div');
                deleteBtn.className = 'delete-preset-btn';
                deleteBtn.textContent = '×';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteSavedList(name);
                };
                
                containerDiv.appendChild(btn);
                containerDiv.appendChild(deleteBtn);
                container.appendChild(containerDiv);
            });
        }
        
        function deleteSavedList(name) {
            if (confirm(`Вы уверены, что хотите удалить пресет "${name}"?`)) {
                const savedLists = getSavedFrequencyLists();
                delete savedLists[name];
                saveFrequencyLists(savedLists);
                renderSavedLists();
            }
        }
        
        function toggleSavedLists() {
            const content = document.getElementById('savedListsContent');
            content.style.display = content.style.display === 'block' ? 'none' : 'block';
            renderSavedLists();
        }
        
        function applyFrequencyList(listName, listData) {
        if (isPlaying) {
        togglePlayback();
        }
        if (isFrequencyCycling) {
        stopFrequencyCycle();
        }
        
        document.querySelectorAll('.frequency-item').forEach(item => item.remove());
        document.querySelectorAll('tr[data-id]').forEach(row => row.remove());
        
        listData.frequencies.forEach(item => {
        const id = createFrequencyControl(item.freq);
        
        const lastItem = document.querySelector(`.frequency-item[data-id="${id}"]`);
        
        lastItem.querySelector('.phase-shift').value = item.phaseShift;
        lastItem.querySelector('.phase-value').textContent = `${item.phaseShift}°`;
        lastItem.querySelector('.pan-selector').value = item.pan;
        
        if (item.volume !== null && item.volume !== undefined) {
        lastItem.querySelector('.volume-input').value = item.volume;
        }
        
        updateVisualization(id, item.freq);
        });
        
        document.getElementById('fmEnabled').checked = listData.fm.enabled;
        document.getElementById('fmFreq').value = listData.fm.freq;
        document.getElementById('fmDepth').value = listData.fm.depth;
        updateFMParams();
        
        document.querySelectorAll('.frequency-item').forEach(item => {
        const id = item.dataset.id;
        const freq = parseFloat(item.querySelector('.freq-range').value);
        updateVisualization(id, freq);
        });
        
        currentPresetName = listName;
        document.getElementById('saveToWavBtn').style.display = 'block';
        
        // Обновляем текст кнопки WAV
        document.getElementById('saveToWavBtn').textContent = 
        `Сохранить "${listName}" в WAV файл`;
        
        alert(`Список "${listName}" успешно загружен!`);
        }

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.8;
                masterGain.connect(audioContext.destination);
                
                // Создаем анализаторы для визуализации
                const splitter = audioContext.createChannelSplitter(2);
                masterGain.connect(splitter);
                
                leftAnalyser = audioContext.createAnalyser();
                rightAnalyser = audioContext.createAnalyser();
                leftAnalyser.fftSize = 2048;
                rightAnalyser.fftSize = 2048;
                
                splitter.connect(leftAnalyser, 0);
                splitter.connect(rightAnalyser, 1);
                
                fmOscillator = audioContext.createOscillator();
                fmOscillator.type = 'sine';
                fmOscillator.frequency.value = 0;
                fmOscillator.start();
            }
        }

        function createOscillatorChain(freq, pan, phaseShift = 0, volume = null) {
            const oscillator = audioContext.createOscillator();
            const panner = audioContext.createStereoPanner();
            const delayNode = audioContext.createDelay();
            const gainNode = audioContext.createGain();
            
            oscillator.type = currentWaveType;
            oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
            panner.pan.value = pan;
            delayNode.delayTime.value = phaseShift / (360 * freq);
            
            // Устанавливаем громкость: если указана - используем её, иначе 1 (будет нормализовано)
            if (volume !== null && volume !== undefined) {
                gainNode.gain.value = volume / 100; // Преобразуем проценты в коэффициент
            } else {
                gainNode.gain.value = 1;
            }
            
            oscillator.connect(delayNode);
            delayNode.connect(gainNode);
            gainNode.connect(panner);
            panner.connect(masterGain);
            
            let fmGain = null;
            if (fmEnabled) {
                const deviation = freq * (fmDepth / 100);
                
                fmGain = audioContext.createGain();
                fmGain.gain.value = deviation;
                
                fmOscillator.connect(fmGain);
                fmGain.connect(oscillator.frequency);
            }
            
            return { 
                oscillator, 
                panner, 
                delayNode, 
                gainNode,
                fmGain,
                panValue: pan,
                volume: volume
            };
        }

        function calculateLightParameters(frequency) {
            const C = 299792458;
            let lightFreq = frequency;
            let octaves = 0;

            while (lightFreq < 400e12 && octaves++ < 50) lightFreq *= 2;

            const wavelength = (C / lightFreq) * 1e9;

            if (wavelength >= 380 && wavelength <= 780) {
                return {
                    lightFreq: lightFreq / 1e12,
                    wavelength: wavelength.toFixed(1) + ' нм',
                    color: wavelengthToColor(wavelength)
                };
            }
            return null;
        }

        function wavelengthToColor(wl) {
            wl = Math.max(380, Math.min(780, wl));
            let r, g, b, factor;

            if (wl < 440) {
                r = (wl - 380) / 60; g = 0; b = 1;
            } else if (wl < 490) {
                r = 0; g = (wl - 440) / 50; b = 1;
            } else if (wl < 510) {
                r = 0; g = 1; b = (510 - wl) / 20;
            } else if (wl < 580) {
                r = (wl - 510) / 70; g = 1; b = 0;
            } else if (wl < 645) {
                r = 1; g = (645 - wl) / 65; b = 0;
            } else {
                r = 1; g = 0; b = 0;
            }

            factor = wl > 700 ? 0.3 : wl < 420 ? 0.3 + 0.7 * (wl - 380) / 40 : 1;
            const gamma = 0.8;

            return `rgb(${[
                Math.round(255 * Math.pow(r * factor, gamma)),
                Math.round(255 * Math.pow(g * factor, gamma)),
                Math.round(255 * Math.pow(b * factor, gamma))
            ].join(',')})`;
        }

        function updateVisualization(id, frequency) {
            const data = calculateLightParameters(frequency);
            const row = document.querySelector(`tr[data-id="${id}"]`);
            if (!data || !row) return;

            const formattedFrequency = parseFloat(frequency.toFixed(6)).toLocaleString('ru-RU', {
                minimumFractionDigits: 3,
                maximumFractionDigits: 6
            });

            row.innerHTML = `
                <td>${formattedFrequency}</td>
                <td>${data.lightFreq.toFixed(3)}</td>
                <td>${data.wavelength}</td>
                <td><div class="color-box" style="background:${data.color}"></div></td>
            `;
        }

        function updateDividers() {
            const container = document.getElementById('frequencyControls');
            const items = container.querySelectorAll('.frequency-item');
            container.querySelectorAll('.divider').forEach(div => div.remove());
            items.forEach((item, index) => {
                if (index < items.length - 1) {
                    const divider = document.createElement('div');
                    divider.className = 'divider';
                    item.after(divider);
                }
            });
        }

        function createFrequencyControl(defaultFrequency = 432, defaultVolume = null) {
            const id = Date.now().toString();
            const div = document.createElement('div');
            div.className = 'frequency-item';
            div.dataset.id = id;
            
            const volumeValue = defaultVolume !== null ? defaultVolume : '';
            
            div.innerHTML = `
                <input type="range" class="freq-range" min="1" max="20000" value="${defaultFrequency}" step="0.001" style="width: 120px;">
                <input type="number" class="freq-number" value="${defaultFrequency}" step="0.001" style="width: 80px;">
                <br>
                <div class="phase-control">
                    <input type="range" class="phase-shift" min="0" max="180" value="0" step="0.1" style="width: 160px;">
                    <span class="phase-value">0°</span>
                </div>
                <select class="pan-selector" style="width: 45px;">
                    <option value="-1">L</option>
                    <option value="0" selected>C</option>
                    <option value="1">R</option>
                </select>
                <div class="volume-control">
                    <span class="volume-icon">🔊</span>
                    <input type="number" class="volume-input" min="0" max="100" value="${volumeValue}" placeholder="%" title="Громкость в % (оставьте пустым для авто)">
                </div>
                <button class="remove-btn" onclick="removeFrequency('${id}')">×</button>
            `;

            const freqRange = div.querySelector('.freq-range');
            const freqNumber = div.querySelector('.freq-number');
            const phaseShift = div.querySelector('.phase-shift');
            const phaseValue = div.querySelector('.phase-value');
            const volumeInput = div.querySelector('.volume-input');

            freqNumber.addEventListener('input', () => {
                const sanitized = freqNumber.value.replace(',', '.');
                const val = parseFloat(sanitized);
                if (!isNaN(val)) {
                    freqRange.value = val;
                    updateVisualization(id, val);
                    if (channels.has(id)) {
                        channels.get(id).oscillator.frequency.setValueAtTime(val, audioContext.currentTime);
                        
                        if (fmEnabled && channels.get(id).fmGain) {
                            const deviation = val * (fmDepth / 100);
                            channels.get(id).fmGain.gain.value = deviation;
                        }
                    }
                }
            });

            freqRange.addEventListener('input', () => {
                const val = parseFloat(freqRange.value);
                freqNumber.value = val;
                updateVisualization(id, val);
                if (channels.has(id)) {
                    channels.get(id).oscillator.frequency.setValueAtTime(val, audioContext.currentTime);
                    
                    if (fmEnabled && channels.get(id).fmGain) {
                        const deviation = val * (fmDepth / 100);
                        channels.get(id).fmGain.gain.value = deviation;
                    }
                }
            });

            phaseShift.addEventListener('input', () => {
                const deg = parseFloat(phaseShift.value);
                phaseValue.textContent = `${deg.toFixed(1)}°`;
                if (channels.has(id)) {
                    const { oscillator, delayNode } = channels.get(id);
                    const freq = oscillator.frequency.value;
                    delayNode.delayTime.value = deg / (360 * freq);
                }
            });

            volumeInput.addEventListener('input', () => {
                if (channels.has(id)) {
                    const volumeValue = volumeInput.value.trim();
                    if (volumeValue === '') {
                        // Если поле пустое - используем автоматическую нормализацию
                        recalculateGains();
                    } else {
                        const volume = parseFloat(volumeValue);
                        if (!isNaN(volume) && volume >= 0 && volume <= 100) {
                            channels.get(id).gainNode.gain.value = volume / 100;
                        }
                    }
                }
            });

            document.getElementById('frequencyControls').appendChild(div);
            updateDividers();

            const row = document.createElement('tr');
            row.dataset.id = id;
            document.getElementById('results').appendChild(row);
            updateVisualization(id, defaultFrequency);
            
            return id;
        }

        function removeFrequency(id) {
            document.querySelector(`.frequency-item[data-id="${id}"]`)?.remove();
            document.querySelector(`tr[data-id="${id}"]`)?.remove();
            if (channels.has(id)) {
                channels.get(id).oscillator.stop();
                channels.delete(id);
                recalculateGains(); // Пересчитываем громкости после удаления
            }
            updateDividers();
        }

        function setWaveType(type) {
            currentWaveType = type;
            
            document.querySelectorAll('.wave-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`${type}Btn`).classList.add('active');
            
            if (isPlaying) {
                channels.forEach(chain => {
                    chain.oscillator.type = type;
                });
            }
            
            if (isFrequencyCycling) {
                currentPairOscillators.forEach(chain => {
                    chain.oscillator.type = type;
                });
            }
        }
        
        function togglePlayback() {
            if (isFrequencyCycling) {
                stopFrequencyCycle();
            }
            
            initAudio();
            isPlaying = !isPlaying;
            const toggleBtn = document.getElementById('toggleBtn');
            toggleBtn.textContent = isPlaying ? 'Стоп' : 'Старт';
            toggleBtn.classList.toggle('active', isPlaying);
            
            document.getElementById('addFrequency').disabled = isPlaying;
            document.getElementById('cycleFrequencies').disabled = isPlaying;
            toggleBtn.disabled = false;
            
            if (isPlaying) {
                // Проверяем, есть ли хотя бы одно поле громкости заполненное
                const hasCustomVolumes = Array.from(document.querySelectorAll('.volume-input'))
                    .some(input => input.value.trim() !== '');
                
                if (hasCustomVolumes) {
                    // Используем пользовательские настройки громкости
                    document.querySelectorAll('.frequency-item').forEach(item => {
                        const id = item.dataset.id;
                        const freq = parseFloat(item.querySelector('.freq-range').value);
                        const pan = parseFloat(item.querySelector('.pan-selector').value);
                        const deg = parseFloat(item.querySelector('.phase-shift').value);
                        const volumeInput = item.querySelector('.volume-input');
                        const volumeValue = volumeInput.value.trim();
                        
                        let volume = null;
                        if (volumeValue !== '') {
                            volume = parseFloat(volumeValue);
                            if (isNaN(volume) || volume < 0 || volume > 100) {
                                volume = 100; // Значение по умолчанию если некорректное
                            }
                        }
                        
                        const chain = createOscillatorChain(freq, pan, deg, volume);
                        channels.set(id, chain);
                        chain.oscillator.start();
                    });
                } else {
                    // Используем автоматическую нормализацию
                    recalculateGains();
                }
            } else {
                channels.forEach(chain => {
                    chain.oscillator.stop();
                });
                channels.clear();
                document.getElementById('addFrequency').disabled = false;
                document.getElementById('cycleFrequencies').disabled = false;
            }
            
            // Управление визуализацией
            if (isPlaying) {
                oscilloscopeCtx.clearRect(0, 0, oscilloscopeCanvas.width, oscilloscopeCanvas.height);
                lissajousCtx.clearRect(0, 0, lissajousCanvas.width, lissajousCanvas.height);
                
                visualizerAnimationId = requestAnimationFrame(drawVisualizer);
            } else {
                cancelAnimationFrame(visualizerAnimationId);
            }
        }

        function recalculateGains() {
            if (!isPlaying) return;
            
            // Вычисляем суммарные коэффициенты для левого и правого каналов
            let totalLeftGain = 0;
            let totalRightGain = 0;
            
            document.querySelectorAll('.frequency-item').forEach(item => {
                const pan = parseFloat(item.querySelector('.pan-selector').value);
                const leftGain = pan <= 0 ? 1 : 1 - pan;
                const rightGain = pan >= 0 ? 1 : 1 + pan;
                totalLeftGain += leftGain;
                totalRightGain += rightGain;
            });
            
            const maxGain = Math.max(totalLeftGain, totalRightGain, 1);
            const gainValue = 1 / maxGain;
            
            document.querySelectorAll('.frequency-item').forEach(item => {
                const id = item.dataset.id;
                const freq = parseFloat(item.querySelector('.freq-range').value);
                const pan = parseFloat(item.querySelector('.pan-selector').value);
                const deg = parseFloat(item.querySelector('.phase-shift').value);
                
                if (!channels.has(id)) {
                    const chain = createOscillatorChain(freq, pan, deg, null);
                    channels.set(id, chain);
                    chain.oscillator.start();
                }
                
                channels.get(id).gainNode.gain.value = gainValue;
            });
        }

        function startFrequencyCycle() {
            if (isPlaying) {
                togglePlayback();
            }
            
            const frequencyItems = document.querySelectorAll('.frequency-item');
            if (frequencyItems.length === 0) {
                alert('Добавьте частоты для перебора');
                return;
            }
            
            frequencyPairs = [];
            const frequencies = [];
            
            frequencyItems.forEach(item => {
                const id = item.dataset.id;
                const freq = parseFloat(item.querySelector('.freq-range').value);
                const phaseShift = parseFloat(item.querySelector('.phase-shift').value);
                const pan = parseFloat(item.querySelector('.pan-selector').value);
                const volumeInput = item.querySelector('.volume-input');
                const volumeValue = volumeInput.value.trim();
                let volume = null;
                if (volumeValue !== '') {
                    volume = parseFloat(volumeValue);
                    if (isNaN(volume) || volume < 0 || volume > 100) {
                        volume = 100;
                    }
                }
                
                frequencies.push({ id, freq, phaseShift, pan, volume });
            });
            
            for (let i = 0; i < frequencies.length; i += 2) {
                const pair = frequencies.slice(i, i + 2);
                frequencyPairs.push(pair);
            }
            
            if (frequencyPairs.length === 0) return;
            
            totalCycleTime = frequencyPairs.length * 3 * 60;
            remainingTime = totalCycleTime;
            
            isFrequencyCycling = true;
            const cycleBtn = document.getElementById('cycleFrequencies');
            cycleBtn.classList.add('active');
            cycleBtn.textContent = formatTime(remainingTime);
            
            document.getElementById('addFrequency').disabled = true;
            document.getElementById('toggleBtn').disabled = true;
            cycleBtn.disabled = false;
            
            currentPairIndex = 0;
            playFrequencyPair(frequencyPairs[currentPairIndex]);
            
            cycleInterval = setInterval(() => {
                stopCurrentPair();
                currentPairIndex++;
                
                if (currentPairIndex < frequencyPairs.length) {
                    playFrequencyPair(frequencyPairs[currentPairIndex]);
                } else {
                    stopFrequencyCycle();
                }
            }, 3 * 60 * 1000);
            
            countdownInterval = setInterval(() => {
                remainingTime--;
                cycleBtn.textContent = formatTime(remainingTime);
                
                if (remainingTime <= 0) {
                    clearInterval(countdownInterval);
                }
            }, 1000);
            
            // Запускаем визуализацию
            visualizerAnimationId = requestAnimationFrame(drawVisualizer);
        }
        
        function stopFrequencyCycle() {
            clearInterval(cycleInterval);
            clearInterval(countdownInterval);
            stopCurrentPair();
            
            isFrequencyCycling = false;
            const cycleBtn = document.getElementById('cycleFrequencies');
            cycleBtn.classList.remove('active');
            cycleBtn.textContent = 'перебор частот';
            
            document.getElementById('addFrequency').disabled = false;
            document.getElementById('toggleBtn').disabled = false;
            cycleBtn.disabled = false;
            
            // Останавливаем визуализацию
            cancelAnimationFrame(visualizerAnimationId);
        }
        
        function playFrequencyPair(pair) {
            initAudio();
            stopCurrentPair();
            
            // Проверяем, есть ли пользовательские настройки громкости
            const hasCustomVolumes = pair.some(freqItem => freqItem.volume !== null);
            
            if (hasCustomVolumes) {
                // Используем пользовательские настройки громкости
                currentPairOscillators = [];
                pair.forEach(freqItem => {
                    const { freq, pan, phaseShift, volume } = freqItem;
                    const chain = createOscillatorChain(freq, pan, phaseShift, volume);
                    chain.oscillator.start();
                    currentPairOscillators.push(chain);
                });
            } else {
                // Используем автоматическую нормализацию
                let leftSum = 0;
                let rightSum = 0;
                
                pair.forEach(freqItem => {
                    const pan = freqItem.pan;
                    leftSum += pan <= 0 ? 1 : 1 - pan;
                    rightSum += pan >= 0 ? 1 : 1 + pan;
                });
                
                const maxSum = Math.max(leftSum, rightSum, 1);
                const normalizationFactor = 1 / maxSum;
                
                currentPairOscillators = [];
                pair.forEach(freqItem => {
                    const { freq, pan, phaseShift } = freqItem;
                    const chain = createOscillatorChain(freq, pan, phaseShift, null);
                    chain.gainNode.gain.value = normalizationFactor * 0.5;
                    chain.oscillator.start();
                    currentPairOscillators.push(chain);
                });
            }
        }
        
        function stopCurrentPair() {
            currentPairOscillators.forEach(chain => {
                try {
                    chain.oscillator.stop();
                    chain.oscillator.disconnect();
                    
                    if (chain.fmGain) {
                        chain.fmGain.disconnect();
                    }
                } catch (e) {
                    console.log("Ошибка при остановке осциллятора", e);
                }
            });
            currentPairOscillators = [];
        }
        
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
        }
        
        function exportPresets() {
            const fileName = prompt('Введите название файла (без расширения)', 'frequency') || 'frequency';
            const fullFileName = `${fileName}.csv`;
            
            const savedLists = getSavedFrequencyLists();
            
            let csvContent = "preset_name,freq,phase,pan,volume,fm_enabled,fm_freq,fm_depth\n";
            
            for (const [presetName, presetData] of Object.entries(savedLists)) {
                const fmEnabled = presetData.fm.enabled ? 1 : 0;
                const fmFreq = parseFloat(presetData.fm.freq).toFixed(6);
                const fmDepth = parseFloat(presetData.fm.depth).toFixed(3);
                
                presetData.frequencies.forEach(freqItem => {
                    const { freq, phaseShift, pan, volume } = freqItem;
                    const formattedFreq = parseFloat(freq).toFixed(6);
                    const formattedPhase = parseFloat(phaseShift).toFixed(3);
                    const formattedPan = parseFloat(pan).toFixed(3);
                    const formattedVolume = volume !== null ? volume.toString() : '';
                    
                    csvContent += `"${presetName}",${formattedFreq},${formattedPhase},${formattedPan},${formattedVolume},${fmEnabled},${fmFreq},${fmDepth}\n`;
                });
            }
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            
            link.setAttribute("href", url);
            link.setAttribute("download", fullFileName);
            link.style.visibility = 'hidden';
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
        
        function importPresets(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                const content = e.target.result;
                const lines = content.split('\n').filter(line => line.trim() !== '');
                
                if (lines.length < 1 || !lines[0].includes('preset_name')) {
                    alert('Неверный формат CSV файла');
                    return;
                }
                
                const newPresets = {};
                
                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    
                    const values = line.split(',');
                    if (values.length < 8) continue;
                    
                    const presetName = values[0].replace(/^"|"$/g, '');
                    const freq = parseFloat(values[1]);
                    const phase = parseFloat(values[2]);
                    const pan = parseFloat(values[3]);
                    const volumeStr = values[4].trim();
                    const volume = volumeStr !== '' ? parseFloat(volumeStr) : null;
                    const fmEnabled = parseInt(values[5]) === 1;
                    const fmFreq = parseFloat(values[6]);
                    const fmDepth = parseFloat(values[7]);
                    
                    if (!newPresets[presetName]) {
                        newPresets[presetName] = {
                            frequencies: [],
                            fm: { enabled: fmEnabled, freq: fmFreq, depth: fmDepth }
                        };
                    }
                    
                    newPresets[presetName].frequencies.push({
                        freq: parseFloat(freq.toFixed(6)),
                        phaseShift: parseFloat(phase.toFixed(3)),
                        pan: parseFloat(pan.toFixed(3)),
                        volume: volume
                    });
                }
                
                const savedLists = getSavedFrequencyLists();
                const mergedPresets = { ...savedLists, ...newPresets };
                saveFrequencyLists(mergedPresets);
                renderSavedLists();
                alert('Пресеты успешно импортированы!');
            };
            
            reader.readAsText(file);
        }
        
        function toggleInfo() {
            const content = document.getElementById('infoContent');
            content.style.display = content.style.display === 'block' ? 'none' : 'block';
        }
        
        function savePresetFromString() {
            const input = document.getElementById('quickPresetInput').value.trim();
            if (!input) {
                alert('Введите частоты');
                return;
            }

            // Парсим строку в формате: "частота,громкость; частота,громкость; ..."
            const frequencyPairs = input.split(';').map(pair => pair.trim()).filter(pair => pair !== '');
            const frequencies = [];
            
            for (let i = 0; i < frequencyPairs.length; i++) {
                const pair = frequencyPairs[i];
                const parts = pair.split(',').map(part => part.trim());
                
                if (parts.length < 1) continue;
                
                // Парсим частоту
                const freqStr = parts[0].replace(',', '.');
                const freq = parseFloat(freqStr);
                if (isNaN(freq)) {
                    alert(`Неверная частота: ${parts[0]}`);
                    return;
                }
                
                // Парсим громкость (если указана)
                let volume = null;
                if (parts.length >= 2) {
                    const volumeStr = parts[1].replace(',', '.');
                    volume = parseFloat(volumeStr);
                    if (isNaN(volume) || volume < 0 || volume > 100) {
                        alert(`Неверная громкость: ${parts[1]}. Должна быть от 0 до 100`);
                        return;
                    }
                }
                
                // Создаем пару осцилляторов для стерео эффекта
                frequencies.push({
                    freq: freq,
                    phaseShift: 0,
                    pan: -1,
                    volume: volume
                });
                
                frequencies.push({
                    freq: freq,
                    phaseShift: 90,
                    pan: 1,
                    volume: volume
                });
            }

            const fmParams = {
                enabled: false,
                freq: 0,
                depth: 0
            };

            const presetName = prompt('Введите название пресета для введённой последовательности частот:');
            if (!presetName) return;

            const presetData = {
                frequencies,
                fm: fmParams
            };

            const savedLists = getSavedFrequencyLists();
            savedLists[presetName] = presetData;
            saveFrequencyLists(savedLists);
            renderSavedLists();
            document.getElementById('quickPresetInput').value = '';
            alert(`Пресет "${presetName}" сохранен!`);
        }

        function initScrollTopButton() {
            const scrollBtn = document.getElementById('scrollToTopBtn');
            
            window.addEventListener('scroll', () => {
                if (window.scrollY > 300) {
                    scrollBtn.style.display = 'block';
                } else {
                    scrollBtn.style.display = 'none';
                }
            });
            
            scrollBtn.addEventListener('click', () => {
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });
        }
        
        function toggleAccordion(id) {
            const content = document.getElementById(id);
            const btn = content.previousElementSibling;
            
            if (content.style.display === 'block') {
                content.style.display = 'none';
                btn.classList.remove('expanded');
            } else {
                content.style.display = 'block';
                btn.classList.add('expanded');
            }
        }
        
        // Функции для сохранения в WAV
        function openWavModal() {
        if (!currentPresetName) {
        alert('Сначала загрузите пресет');
        return;
        }
        
        // Обновляем заголовок с именем пресета
        document.querySelector('.wav-modal-content h3').textContent = 
        `Сохранить пресет "${currentPresetName}" в WAV файл`;
        
        // Синхронизируем FM настройки с основными
        document.getElementById('wavFmEnabled').checked = document.getElementById('fmEnabled').checked;
        document.getElementById('wavModal').style.display = 'block';
        }
        
        function startWavGeneration() {
        console.log('=== DEBUG WAV GENERATION ===');
        console.log('currentPresetName:', currentPresetName);
        console.log('waveType:', currentWaveType);
        console.log('fmEnabled:', document.getElementById('wavFmEnabled').checked);
        
        const preset = getSavedFrequencyLists()[currentPresetName];
        if (!preset) {
        alert('Пресет не найден: ' + currentPresetName);
        return;
        }        
        
        const config = {
        presetName: currentPresetName, // ✅ Актуальное имя пресета
        frequencies: preset.frequencies,
        waveType: currentWaveType, // ✅ Актуальный тип волны
        fmEnabled: document.getElementById('wavFmEnabled').checked, // ✅ Актуальные настройки FM из модального окна
        fmFreq: parseFloat(document.getElementById('fmFreq').value),
        fmDepth: parseFloat(document.getElementById('fmDepth').value),duration: parseFloat(document.getElementById('wavDuration').value),
        sampleRate: parseInt(document.getElementById('wavSampleRate').value),
        bitDepth: parseInt(document.getElementById('wavBitDepth').value),
        volume: parseFloat(document.getElementById('wavVolume').value) / 100,
        stereo: document.getElementById('wavStereo').checked,
        //normalize: document.getElementById('wavNormalize').checked,
        compress: document.getElementById('wavCompress').checked
        };
        
        // Запускаем генерацию в Web Worker
        if (!wavWorker) {
        wavWorker = new Worker(URL.createObjectURL(new Blob([
        `(${wavWorkerFunction.toString()})()`
        ], {type: 'application/javascript'})));
        
        wavWorker.onmessage = function(e) {
        if (e.data.type === 'progress') {
        document.getElementById('wavProgress').style.width = `${e.data.value}%`;
        document.getElementById('wavStatus').textContent = `Генерация: ${Math.round(e.data.value)}%`;
        }
        else if (e.data.type === 'complete') {
        const blob = new Blob([e.data.wavData], { type: 'audio/wav' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = generateWavFilename();
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        document.getElementById('wavStatus').textContent = 'Готово! Файл сохранен';
        setTimeout(() => {
        document.getElementById('wavModal').style.display = 'none';
        }, 2000);
        }
        else if (e.data.type === 'error') {
        document.getElementById('wavStatus').textContent = 'Ошибка: ' + e.data.message;
        }
        };
        }
        
        document.getElementById('wavStatus').textContent = 'Начало генерации...';
        wavWorker.postMessage(config);
        }
        
        function generateWavFilename() {
        // Всегда получаем актуальные значения в момент генерации
        const presetName = currentPresetName || 'unknown';
        const waveType = currentWaveType;
        const fmEnabled = document.getElementById('wavFmEnabled').checked;
        
        const waveChar = waveType === 'sine' ? 's' : 'm';
        const fmChar = fmEnabled ? 'f' : '';
        
        return `${presetName}_${waveChar}${fmChar}.wav`;
        }
        
        // Web Worker функция для генерации WAV
        function wavWorkerFunction() {
            self.onmessage = function(e) {
                const config = e.data;
                const sampleRate = config.sampleRate;
                const duration = config.duration;
                const numSamples = Math.floor(duration * sampleRate);
                const numChannels = config.stereo ? 2 : 1;
                const buffer = new ArrayBuffer(44 + numSamples * numChannels * 2);
                const view = new DataView(buffer);
                
                // Write WAV header
                function writeString(view, offset, string) {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                }
                
                writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + numSamples * numChannels * 2, true);
                writeString(view, 8, 'WAVE');
                writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true); // PCM format
                view.setUint16(22, numChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * numChannels * 2, true); // byte rate
                view.setUint16(32, numChannels * 2, true); // block align
                view.setUint16(34, 16, true); // bits per sample
                writeString(view, 36, 'data');
                view.setUint32(40, numSamples * numChannels * 2, true);
                
                // Generate audio data
                const dataOffset = 44;
                const samples = new Float32Array(numSamples * numChannels);
                const volume = config.volume;
                
                // Функция для расчета частоты с FM модуляцией
                function calculateFrequency(baseFreq, time, fmFreq, fmDepth) {
                    if (!config.fmEnabled) return baseFreq;
                    return baseFreq + baseFreq * (fmDepth / 100) * Math.sin(2 * Math.PI * fmFreq * time);
                }
                
                // Генерация данных
                for (let i = 0; i < numSamples; i++) {
                    const time = i / sampleRate;
                    
                    // Суммируем все частоты
                    for (const freq of config.frequencies) {
                        const effectiveFreq = calculateFrequency(freq.freq, time, config.fmFreq, config.fmDepth);
                        const phaseShift = freq.phaseShift * (Math.PI / 180);
                        let channelValue = 0;
                        
                        if (config.waveType === 'sine') {
                            channelValue = Math.sin(2 * Math.PI * effectiveFreq * time + phaseShift);
                        } else { // square wave
                            const period = 1 / effectiveFreq;
                            const position = (time % period) / period;
                            channelValue = position < 0.5 ? 1 : -1;
                        }
                        
                        // Применяем пользовательскую громкость если указана
                        let gain = 1;
                        if (freq.volume !== null && freq.volume !== undefined) {
                            gain = freq.volume / 100;
                        }
                        
                        channelValue *= gain;
                        
                        // Применяем панорамирование
                        if (config.stereo) {
                            const pan = freq.pan;
                            const leftGain = pan <= 0 ? 1 : 1 - pan;
                            const rightGain = pan >= 0 ? 1 : 1 + pan;
                            
                            samples[i * numChannels] += channelValue * leftGain;
                            samples[i * numChannels + 1] += channelValue * rightGain;
                        } else {
                            samples[i] += channelValue;
                        }
                    }
                    
                    // Отправляем прогресс каждые 1000 сэмплов
                    if (i % 1000 === 0) {
                        const progress = (i / numSamples) * 100;
                        self.postMessage({ type: 'progress', value: progress });
                    }
                }
                
                // Упрощенная умная нормализация
                // Умная нормализация - проверяем максимальную амплитуду
                let maxAmplitude = 0;
                for (let i = 0; i < samples.length; i++) {
                if (Math.abs(samples[i]) > maxAmplitude) maxAmplitude = Math.abs(samples[i]);
                }
                
                // Применяем нормализацию в зависимости от ситуации
                if (maxAmplitude > 1.0) {
                // Случай 1: Обнаружен клиппинг - нормализуем до 0.99
                const normalizeFactor = 0.99 / maxAmplitude;
                for (let i = 0; i < samples.length; i++) {
                samples[i] *= normalizeFactor * volume;
                }
                console.log(`Нормализация от клиппинга: ${maxAmplitude.toFixed(3)} → 0.99`);
                } else if (maxAmplitude > 0 && maxAmplitude < 1.0) {
                // Случай 2: Сигнал тихий - усиливаем до 1.0
                const normalizeFactor = 1.0 / maxAmplitude;
                for (let i = 0; i < samples.length; i++) {
                samples[i] *= normalizeFactor * volume;
                }
                console.log(`Усиление тихого сигнала: ${maxAmplitude.toFixed(3)} → 1.0`);
                } else if (maxAmplitude === 1.0) {
                // Случай 3: Идеальный уровень - просто применяем громкость
                for (let i = 0; i < samples.length; i++) {
                samples[i] *= volume;
                }
                console.log('Идеальный уровень, применяем громкость');
                } else {
                // Случай 4: Тишина (maxAmplitude = 0)
                for (let i = 0; i < samples.length; i++) {
                samples[i] *= volume;
                }
                console.log('Тихий сигнал, применяем громкость');
                }
                
                // Запись данных в буфер
                let index = dataOffset;
                for (let i = 0; i < samples.length; i++) {
                    const s = Math.max(-1, Math.min(1, samples[i]));
                    const val = s < 0 ? s * 32768 : s * 32767;
                    view.setInt16(index, val, true);
                    index += 2;
                }
                
                self.postMessage({ type: 'complete', wavData: buffer });
            };
        }

        // Инициализация визуализатора
        function initVisualizer() {
            oscilloscopeCanvas = document.getElementById('oscilloscopeCanvas');
            lissajousCanvas = document.getElementById('lissajousCanvas');
            oscilloscopeCtx = oscilloscopeCanvas.getContext('2d');
            lissajousCtx = lissajousCanvas.getContext('2d');
            
            oscilloscopeCanvas.width = oscilloscopeCanvas.offsetWidth;
            oscilloscopeCanvas.height = oscilloscopeCanvas.offsetHeight;
            
            lissajousCanvas.width = lissajousCanvas.offsetWidth;
            lissajousCanvas.height = lissajousCanvas.offsetHeight;
        }
        
        // Отрисовка визуализатора с двумя каналами
        function drawVisualizer() {
            if (!isPlaying && !isFrequencyCycling) {
                cancelAnimationFrame(visualizerAnimationId);
                return;
            }
            
            if (!leftAnalyser || !rightAnalyser) return;
            
            const oscWidth = oscilloscopeCanvas.width;
            const oscHeight = oscilloscopeCanvas.height;
            const lissWidth = lissajousCanvas.width;
            const lissHeight = lissajousCanvas.height;
            
            oscilloscopeCtx.clearRect(0, 0, oscWidth, oscHeight);
            lissajousCtx.clearRect(0, 0, lissWidth, lissHeight);
            
            const bufferLength = leftAnalyser.fftSize;
            const leftData = new Uint8Array(bufferLength);
            const rightData = new Uint8Array(bufferLength);
            
            leftAnalyser.getByteTimeDomainData(leftData);
            rightAnalyser.getByteTimeDomainData(rightData);
            
            const visibleSamples = Math.min(bufferLength, visualizerConfig.visibleSamples);
            const startIndex = Math.max(0, Math.floor(bufferLength / 2 - visibleSamples / 2));
            const sliceWidth = oscWidth / visibleSamples;
            
            // Рисуем левый канал
            oscilloscopeCtx.beginPath();
            oscilloscopeCtx.strokeStyle = visualizerConfig.leftChannelColor;
            oscilloscopeCtx.lineWidth = visualizerConfig.lineWidth;
            
            let x = 0;
            for (let i = 0; i < visibleSamples; i++) {
                const index = startIndex + i;
                const amplitude = (leftData[index] - 128) / 128;
                const y = oscHeight / 2 + amplitude * (oscHeight / 2 * visualizerConfig.amplitudeScale);
                
                if (i === 0) {
                    oscilloscopeCtx.moveTo(x, y);
                } else {
                    oscilloscopeCtx.lineTo(x, y);
                }
                
                x += sliceWidth;
            }
            oscilloscopeCtx.stroke();
            
            // Рисуем правый канал
            oscilloscopeCtx.beginPath();
            oscilloscopeCtx.strokeStyle = visualizerConfig.rightChannelColor;
            oscilloscopeCtx.lineWidth = visualizerConfig.lineWidth;
            
            x = 0;
            for (let i = 0; i < visibleSamples; i++) {
                const index = startIndex + i;
                const amplitude = (rightData[index] - 128) / 128;
                const y = oscHeight / 2 + amplitude * (oscHeight / 2 * visualizerConfig.amplitudeScale);
                
                if (i === 0) {
                    oscilloscopeCtx.moveTo(x, y);
                } else {
                    oscilloscopeCtx.lineTo(x, y);
                }
                
                x += sliceWidth;
            }
            oscilloscopeCtx.stroke();
            
            // Рисуем центральную линию
            oscilloscopeCtx.beginPath();
            oscilloscopeCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            oscilloscopeCtx.lineWidth = 1;
            oscilloscopeCtx.moveTo(0, oscHeight / 2);
            oscilloscopeCtx.lineTo(oscWidth, oscHeight / 2);
            oscilloscopeCtx.stroke();
            
            // Рисуем фигуру Лиссажу
            lissajousCtx.beginPath();
            lissajousCtx.strokeStyle = '#FF00FF';
            lissajousCtx.lineWidth = 1;
            
            const squareSize = Math.min(lissWidth, lissHeight) * 0.8;
            const centerX = lissWidth / 2;
            const centerY = lissHeight / 2;
            
            for (let i = 0; i < visibleSamples; i++) {
                const index = startIndex + i;
                const xAmplitude = (leftData[index] - 128) / 128;
                const yAmplitude = (rightData[index] - 128) / 128;
                
                const x = centerX + xAmplitude * squareSize / 2;
                const y = centerY + yAmplitude * squareSize / 2;
                
                if (i === 0) {
                    lissajousCtx.moveTo(x, y);
                } else {
                    lissajousCtx.lineTo(x, y);
                }
            }
            
            lissajousCtx.stroke();
            
            // Рисуем перекрестие
            lissajousCtx.beginPath();
            lissajousCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            lissajousCtx.lineWidth = 1;
            lissajousCtx.moveTo(centerX, centerY - squareSize/2);
            lissajousCtx.lineTo(centerX, centerY + squareSize/2);
            lissajousCtx.moveTo(centerX - squareSize/2, centerY);
            lissajousCtx.lineTo(centerX + squareSize/2, centerY);
            lissajousCtx.stroke();
            
            visualizerAnimationId = requestAnimationFrame(drawVisualizer);
        }

        document.getElementById('addFrequency').addEventListener('click', () => {
            createFrequencyControl();
        });

        document.getElementById('toggleBtn').addEventListener('click', togglePlayback);

        document.getElementById('sineBtn').addEventListener('click', () => setWaveType('sine'));
        document.getElementById('squareBtn').addEventListener('click', () => setWaveType('square'));
        
        document.getElementById('fmEnabled').addEventListener('change', updateFMParams);
        document.getElementById('fmFreq').addEventListener('input', updateFMParams);
        document.getElementById('fmDepth').addEventListener('input', updateFMParams);
        
        document.getElementById('saveListBtn').addEventListener('click', showNamePrompt);
        
        document.getElementById('cycleFrequencies').addEventListener('click', () => {
            if (isFrequencyCycling) {
                stopFrequencyCycle();
            } else {
                startFrequencyCycle();
            }
        });
        
        document.getElementById('exportBtn').addEventListener('click', exportPresets);
        document.getElementById('importBtn').addEventListener('click', () => {
            document.getElementById('csvFileInput').click();
        });
        document.getElementById('csvFileInput').addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                importPresets(e.target.files[0]);
                e.target.value = '';
            }
        });
        
        document.getElementById('quickSaveBtn').addEventListener('click', savePresetFromString);
        document.getElementById('saveToWavBtn').addEventListener('click', openWavModal);

        function openModal() {
            document.getElementById('infoModal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('infoModal').style.display = 'none';
        }

        function updateFMParams() {
            fmEnabled = document.getElementById('fmEnabled').checked;
            fmFreq = parseFloat(parseFloat(document.getElementById('fmFreq').value || 0).toFixed(6));
            fmDepth = parseFloat(parseFloat(document.getElementById('fmDepth').value || 0).toFixed(3));
            
            if (fmOscillator) {
                fmOscillator.frequency.value = fmFreq;
            }
            
            if (isPlaying) {
                channels.forEach((chain, id) => {
                    const item = document.querySelector(`.frequency-item[data-id="${id}"]`);
                    if (item) {
                        const freq = parseFloat(item.querySelector('.freq-range').value);
                        
                        if (chain.fmGain && !fmEnabled) {
                            chain.fmGain.disconnect();
                            chain.oscillator.frequency.value = freq;
                        } else if (!chain.fmGain && fmEnabled) {
                            const deviation = freq * (fmDepth / 100);
                            chain.fmGain = audioContext.createGain();
                            chain.fmGain.gain.value = deviation;
                            fmOscillator.connect(chain.fmGain);
                            chain.fmGain.connect(chain.oscillator.frequency);
                        } else if (chain.fmGain && fmEnabled) {
                            const deviation = freq * (fmDepth / 100);
                            chain.fmGain.gain.value = deviation;
                        }
                    }
                });
            }
            
            if (isFrequencyCycling && currentPairOscillators.length > 0) {
                currentPairOscillators.forEach(chain => {
                    const freq = chain.oscillator.frequency.value;
                    
                    if (fmEnabled) {
                        const deviation = freq * (fmDepth / 100);
                        
                        if (!chain.fmGain) {
                            chain.fmGain = audioContext.createGain();
                            fmOscillator.connect(chain.fmGain);
                            chain.fmGain.connect(chain.oscillator.frequency);
                        }
                        
                        chain.fmGain.gain.value = deviation;
                    } else if (chain.fmGain) {
                        chain.fmGain.disconnect();
                        chain.fmGain = null;
                    }
                });
            }
        }

        window.onclick = function(event) {
        
            const modal = document.getElementById('infoModal');
            if (event.target === modal) {
                modal.style.display = 'none';
            }
            
            const nameModal = document.getElementById('namePromptModal');
            if (event.target === nameModal) {
                nameModal.style.display = 'none';
            }
            
            const wavModal = document.getElementById('wavModal');
            if (event.target === wavModal) {
                wavModal.style.display = 'none';
            }
        }
        
        window.addEventListener('DOMContentLoaded', () => {
            createFrequencyControl(432);
            renderSavedLists();
            initScrollTopButton();
            initVisualizer();
            
            document.getElementById('freqAccordion').style.display = 'block';
            document.getElementById('colorAccordion').style.display = 'block';
            
            // Обработка изменения размера окна
            window.addEventListener('resize', initVisualizer);
        });
    </script>
    <script>
        if('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js', { scope: '/midi/' })
            .then(reg => console.log('SW registered'))
            .catch(err => console.error('SW error:', err));
        }
    </script>
</body>
</html>
